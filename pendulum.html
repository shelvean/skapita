<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="description" content="Simple Pendulum Simulation Second Order Differential Equation, Damping, Spring Constant">
    <meta name="keywords" content="Pendulum, Simulation, Damping, Spring Constant, Second Order, Differential Equations">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-5B8PRB2WZT"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-5B8PRB2WZT');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Damped Pendulum Simulator</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <style>
        :root {
            --primary: #6c5ce7;
            --secondary: #4a47a3;
            --background: #f8f9fa;
            --surface: #e9ecef;
            --text: #212529;
            --accent: #00b4d8;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            margin: 0;
            padding: 30px;
            background: var(--background);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .main-container {
            max-width: 1200px;
            width: 100%;
            margin: 0 auto;
            padding: 20px;
        }
        .content-wrapper {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            align-items: start;
        }
        .simulation-column {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }
        .controls-wrapper {
            background: rgba(255,255,255,0.9);
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: 14px;
            padding: 1.5rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.06);
        }
        canvas {
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            border: 2px solid var(--surface);
            background: white;
        }
        #simulationCanvas {
            width: 100%;
            height: 400px;
        }
        .graph-container {
            background: white;
            border: 1px solid var(--surface);
            border-radius: 16px;
            padding: 1rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.06);
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        .controls label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 0.9rem;
            color: var(--secondary);
        }
        .controls input {
            width: 80px;
            padding: 0.4rem;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            font-size: 0.9rem;
        }
        button {
            padding: 0.6rem 1rem;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        button:hover {
            background: var(--accent);
            transform: translateY(-1px);
        }
        .alert {
            padding: 1rem;
            background: #f8d7da;
            color: #721c24;
            border-radius: 8px;
            margin-top: 1rem;
        }
        .graph-label {
            font-size: 0.8rem;
            fill: var(--text);
        }
    </style>
</head>
<body>
    <div class="main-container">
        <h1>Damped Pendulum Oscillator</h1>
        <div id="equationGeneral"></div>
        <div class="content-wrapper">
            <div class="simulation-column">
                <canvas id="simulationCanvas" width="500" height="400"></canvas>
                <div class="graph-container">
                    <h2>Phase Space (θ' vs θ)</h2>
                    <canvas id="phaseGraphCanvas" width="300" height="200"></canvas>
                </div>
            </div>
            <div class="controls-wrapper">
                <div class="controls">
                    <div>
                        <label for="length">Length (L) [m]:<input type="number" id="length" value="2" min="0.1" step="0.1"></label>
                        <label for="initialAngle">Initial Angle (θ₀) [rad]:<input type="number" id="initialAngle" value="1.4" step="0.01"></label>
                        <label for="initialVelocity">Angular Velocity (ω₀) [rad/s]:<input type="number" id="initialVelocity" value="1" step="0.1"></label>
                    </div>
                    <div>
                        <label for="mass">Mass (m) [kg]:<input type="number" id="mass" value="1" step="0.1"></label>
                        <label for="damping">Damping (b) [kg/s]:<input type="number" id="damping" value="0.15" step="0.01"></label>
                        <button onclick="resetSimulation()" style="margin-top: 1rem;">Reset Simulation</button>
                    </div>
                </div>
                <div class="graph-container">
                    <h2>Angular Displacement vs Time</h2>
                    <canvas id="graphCanvas" width="350" height="200"></canvas>
                </div>
            </div>
        </div>
        <div id="alertContainer" class="alert" style="display: none;"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');
        const phaseGraphCanvas = document.getElementById('phaseGraphCanvas');
        const phaseGraphCtx = phaseGraphCanvas.getContext('2d');
        const g = 9.81;
        
        let L = 2, theta0 = 1.4, omega0 = 1, m = 1, b = 0.15;
        let theta = theta0, omega = omega0, t = 0;
        const dt = 0.03, graphMaxTime = 30;
        let isSimulationRunning = true;
        const graphData = [];
        let useBackwardEuler = false;

        function calculateDerivatives(theta, omega) {
            const alpha = (-b * omega / m) - (g / L) * Math.sin(theta);
            return { theta: omega, omega: alpha };
        }

        function backwardEulerStep(theta, omega, dt) {
            const denom = 1 + dt * (b / m);
            const F = (theta_next) => theta_next - theta - dt * (omega - (dt * (g / L) * Math.sin(theta_next))) / denom;
            const F_prime = (theta_next) => 1 + (dt * dt * (g / L) * Math.cos(theta_next)) / denom;
            
            let theta_next = theta;
            const tolerance = 1e-6;
            const maxIterations = 100;
            
            for (let i = 0; i < maxIterations; i++) {
                const f_val = F(theta_next);
                const f_prime_val = F_prime(theta_next);
                if (Math.abs(f_prime_val) < 1e-12) break;
                const delta = f_val / f_prime_val;
                theta_next -= delta;
                if (Math.abs(delta) < tolerance) break;
            }
            
            const omega_next = (omega - (dt * (g / L) * Math.sin(theta_next))) / denom;
            return { theta: theta_next, omega: omega_next };
        }

        function updatePhysics() {
            if (!isSimulationRunning) return;
            
            if (Math.abs(theta) > Math.PI / 2) {
                isSimulationRunning = false;
                showAlert("Pendulum angle exceeded π/2 radians! Simulation stopped.");
                return;
            }

            if (useBackwardEuler) {
                const nextState = backwardEulerStep(theta, omega, dt);
                theta = nextState.theta;
                omega = nextState.omega;
            } else {
                const k1 = calculateDerivatives(theta, omega);
                const k2 = calculateDerivatives(
                    theta + (k1.theta * dt) / 2,
                    omega + (k1.omega * dt) / 2
                );
                const k3 = calculateDerivatives(
                    theta + (k2.theta * dt) / 2,
                    omega + (k2.omega * dt) / 2
                );
                const k4 = calculateDerivatives(
                    theta + k3.theta * dt,
                    omega + k3.omega * dt
                );
                
                theta += (k1.theta + 2 * k2.theta + 2 * k3.theta + k4.theta) * dt / 6;
                omega += (k1.omega + 2 * k2.omega + 2 * k3.omega + k4.omega) * dt / 6;
            }

            t += dt;
            graphData.push({ t, theta, omega });
            if (t > graphMaxTime) isSimulationRunning = false;
        }

        function drawPendulum() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const pivotX = canvas.width / 2;
            const pivotY = 60;
            const scale = 120;
            const bobRadius = 18;
            
            ctx.fillStyle = '#333';
            ctx.fillRect(pivotX - 60, 0, 120, 60);
            
            const visualLength = L * scale;
            const bobX = pivotX + visualLength * Math.sin(theta);
            const bobY = pivotY + visualLength * Math.cos(theta);
            
            ctx.beginPath();
            ctx.moveTo(pivotX, pivotY);
            ctx.lineTo(bobX, bobY);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 4;
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(bobX, bobY, bobRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#8B4513';
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.stroke();
        }

        
// Modified drawGraph function with corrected label positioning
		function drawGraph() {
			graphCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);
			
			// Draw axes
			graphCtx.beginPath();
			graphCtx.moveTo(50, 20);
			graphCtx.lineTo(50, graphCanvas.height - 30);  // Increased bottom margin
			graphCtx.lineTo(graphCanvas.width - 20, graphCanvas.height - 30);
			graphCtx.strokeStyle = '#000';
			graphCtx.stroke();

			if (graphData.length === 0) return;

			// Calculate max absolute theta with fallback
			const maxTheta = Math.max(...graphData.map(d => Math.abs(d.theta)));
			const maxAbsTheta = Math.max(maxTheta || 0.001, 0.001);  // Ensure non-zero
			const maxTime = graphMaxTime;

			// Draw vertical axis labels
			graphCtx.fillStyle = '#000';
			graphCtx.font = '10px Arial';
			graphCtx.textAlign = 'right';
			
			// Single loop for both positive and negative labels
			const labelCount = 5;
			for (let i = -labelCount; i <= labelCount; i++) {
				const thetaVal = (i/labelCount) * maxAbsTheta;
				const y = graphCanvas.height - 30 - 
						 ((thetaVal + maxAbsTheta) / (2 * maxAbsTheta)) * 
						 (graphCanvas.height - 50);
				
				// Set appropriate text baseline based on position
				graphCtx.textBaseline = i === -labelCount ? 'top' : 
									   i === labelCount ? 'bottom' : 'middle';
				
				graphCtx.fillText(thetaVal.toFixed(2), 45, y);
			}

			// Draw horizontal axis labels
			graphCtx.textAlign = 'center';
			graphCtx.textBaseline = 'top';
			for (let tVal = 0; tVal <= maxTime; tVal += maxTime/5) {
				const x = 50 + (tVal/maxTime) * (graphCanvas.width - 70);
				graphCtx.fillText(tVal.toFixed(1), x, graphCanvas.height - 25);  // Lowered position
			}

			// Draw curve (existing code remains unchanged)
			graphCtx.beginPath();
			graphCtx.strokeStyle = '#007bff';
			graphCtx.lineWidth = 2;
			const verticalRange = graphCanvas.height - 50;
			
			graphData.forEach((point, idx) => {
				const x = 50 + (point.t/maxTime) * (graphCanvas.width - 70);
				const y = graphCanvas.height - 30 - 
						 ((point.theta + maxAbsTheta) / (2 * maxAbsTheta)) * verticalRange;
				
				if (idx === 0) graphCtx.moveTo(x, y);
				else graphCtx.lineTo(x, y);
			});
			
			graphCtx.stroke();
		}



        function drawPhaseGraph() {
            phaseGraphCtx.clearRect(0, 0, phaseGraphCanvas.width, phaseGraphCanvas.height);
            
            // Add 10% padding to axis ranges
            const maxTheta = Math.max(...graphData.map(d => Math.abs(d.theta))) * 1.1 || 1;
            const maxOmega = Math.max(...graphData.map(d => Math.abs(d.omega))) * 1.1 || 1;
            
            // Draw axes
            phaseGraphCtx.beginPath();
            phaseGraphCtx.moveTo(50, phaseGraphCanvas.height - 30);
            phaseGraphCtx.lineTo(phaseGraphCanvas.width - 30, phaseGraphCanvas.height - 30);
            phaseGraphCtx.moveTo(50, 20);
            phaseGraphCtx.lineTo(50, phaseGraphCanvas.height - 30);
            phaseGraphCtx.strokeStyle = '#000';
            phaseGraphCtx.stroke();

            // Draw labels
            phaseGraphCtx.fillStyle = '#000';
            phaseGraphCtx.font = '10px Arial';
            phaseGraphCtx.textAlign = 'center';
            phaseGraphCtx.textBaseline = 'top';
            
            // X-axis labels
            [-maxTheta, 0, maxTheta].forEach(val => {
                const x = 50 + (val + maxTheta) * (phaseGraphCanvas.width - 80) / (2 * maxTheta);
                phaseGraphCtx.fillText(val.toFixed(1), x, phaseGraphCanvas.height - 15);
            });

            // Y-axis labels
            phaseGraphCtx.textAlign = 'right';
            phaseGraphCtx.textBaseline = 'middle';
            [-maxOmega, 0, maxOmega].forEach(val => {
                const y = phaseGraphCanvas.height - 30 - (val + maxOmega) * (phaseGraphCanvas.height - 50) / (2 * maxOmega);
                phaseGraphCtx.fillText(val.toFixed(1), 40, y);
            });

            if (graphData.length === 0) return;

            // Draw trajectory
            phaseGraphCtx.beginPath();
            phaseGraphCtx.strokeStyle = '#007bff';
            phaseGraphCtx.lineWidth = 1;
            
            graphData.forEach((point, idx) => {
                const x = 50 + (point.theta + maxTheta) * (phaseGraphCanvas.width - 80) / (2 * maxTheta);
                const y = phaseGraphCanvas.height - 30 - (point.omega + maxOmega) * (phaseGraphCanvas.height - 50) / (2 * maxOmega);
                
                if (idx === 0) phaseGraphCtx.moveTo(x, y);
                else phaseGraphCtx.lineTo(x, y);
            });
            
            phaseGraphCtx.stroke();

            // Draw current state dot
            if (graphData.length > 0) {
                const current = graphData[graphData.length - 1];
                const x = 50 + (current.theta + maxTheta) * (phaseGraphCanvas.width - 80) / (2 * maxTheta);
                const y = phaseGraphCanvas.height - 30 - (current.omega + maxOmega) * (phaseGraphCanvas.height - 50) / (2 * maxOmega);
                
                phaseGraphCtx.beginPath();
                phaseGraphCtx.arc(x, y, 4, 0, Math.PI * 2);
                phaseGraphCtx.fillStyle = '#ff0000';
                phaseGraphCtx.fill();
            }
        }

        function updateParameters() {
            L = parseFloat(document.getElementById('length').value);
            theta0 = parseFloat(document.getElementById('initialAngle').value);
            omega0 = parseFloat(document.getElementById('initialVelocity').value);
            m = parseFloat(document.getElementById('mass').value);
            b = parseFloat(document.getElementById('damping').value);
            
            try {
                katex.render(
                    `\\theta'' + \\frac{${b.toFixed(2)}}{${m.toFixed(2)}} \\theta' + \\frac{${g.toFixed(2)}}{${L.toFixed(2)}} \\sin(\\theta) = 0`,
                    document.getElementById('equation'),
                    { throwOnError: false }
                );
            } catch (error) {
                console.error('KaTeX error:', error);
            }
        }

        function resetSimulation() {
            L = parseFloat(document.getElementById('length').value);
            theta0 = parseFloat(document.getElementById('initialAngle').value);
            omega0 = parseFloat(document.getElementById('initialVelocity').value);
            m = parseFloat(document.getElementById('mass').value);
            b = parseFloat(document.getElementById('damping').value);
            
            const D = Math.pow(b / m, 2) - 4 * (g / L);
            useBackwardEuler = D > 0;

            theta = theta0;
            omega = omega0;
            t = 0;
            graphData.length = 0;
            isSimulationRunning = true;
            updateParameters();
            drawPendulum();
            drawGraph();
            drawPhaseGraph();
            removeAlert();
        }

        function showAlert(message) {
            const alertContainer = document.getElementById('alertContainer');
            alertContainer.innerHTML = `
                <div style="background:#f87171;color:white;padding:1rem;border-radius:8px;display:flex;align-items:center;">
                    ${message}
                    <button onclick="removeAlert()" style="margin-left:auto;background:none;border:none;color:white;cursor:pointer;">×</button>
                </div>
            `;
            alertContainer.style.display = 'block';
        }

        function removeAlert() {
            const alertContainer = document.getElementById('alertContainer');
            alertContainer.style.display = 'none';
            alertContainer.innerHTML = '';
        }

        function animate() {
            if (isSimulationRunning) {
                updatePhysics();
                drawPendulum();
                drawGraph();
                drawPhaseGraph();
            }
            requestAnimationFrame(animate);
        }

        document.addEventListener('DOMContentLoaded', () => {
            katex.render(
                `\\theta'' + \\frac{b}{m} \\theta' + \\frac{g}{L} \\sin(\\theta) = 0`,
                document.getElementById('equationGeneral'),
                { throwOnError: false, displayMode: true }
            );
            updateParameters();
            animate();
        });
    </script>
</body>
</html>
