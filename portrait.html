<!DOCTYPE html>
<html>
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-5B8PRB2WZT"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-5B8PRB2WZT');
    </script>
    <title>Linear System Phase Portrait</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f7fb;
        }

        .container {
            background: white;
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 2rem;
        }
        
        .matrix-container {
            display: flex;
            justify-content: center;
            margin: 1rem 0;
        }

        .matrix-row {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .matrix-column {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .matrix-column input {
            width: 60px;
            padding: 0.5rem;
            text-align: center;
        }

        .bracket {
            font-size: 2.5rem;
            color: #2c3e50;
            line-height: 1;
            margin: 0 5px;
        }

        .range-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 1rem 0;
        }

        .range-row {
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .input-group input {
            width: 80px;
            padding: 0.3rem;
            text-align: center;
        }

        .input-group label {
            font-size: 0.9rem;
            color: #2c3e50;
        }

        .matrix-input {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 1rem 0;
        }

        .matrix-input input {
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 30px;
            text-align: center;
        }

        .matrix-input .brackets {
            font-size: 2rem;
            color: #2c3e50;
        }

        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: background 0.3s ease;
            margin: 1rem 0;
        }

        button:hover {
            background: #2980b9;
        }

        canvas {
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-top: 1rem;
        }

        .equation {
            font-size: 1.2rem;
            text-align: center;
            margin: 1rem 0;
            min-height: 60px;
        }
        .click-instruction {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.2rem;
            color: #2c3e50;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 16px;
            border-radius: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            opacity: 1;
            transition: opacity 2s ease-out;
            pointer-events: none;
        }
        .fade-out {
            opacity: 0;
        }
        .button-container {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 1rem 0;
        }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: background 0.3s ease;
        }
        button:hover {
            background: #2980b9;
        }
        button.clear {
            background: #e74c3c;
        }
        button.clear:hover {
            background: #c0392b;
        }
        .scale-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            margin-top: 10px;
        }
        .x-scale {
            display: flex;
            justify-content: space-between;
            width: 600px; /* Increased to match canvas */
            font-size: 0.9rem;
            color: #2c3e50;
            margin-top: 10px; /* Position below the canvas */
        }
        .y-scale {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 450px; /* Increased to match canvas */
            font-size: 0.9rem;
            color: #2c3e50;
            margin-right: 10px;
        }
        .canvas-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Linear System Phase Portrait</h1>
        <div class="equation" id="equation-display"></div>
        
        <!-- Matrix Input -->
        <div class="matrix-container">
            <div class="matrix-row">
                <span class="bracket">[</span>
                <div class="matrix-column">
                    <input type="number" id="a" placeholder="a" step="any" value="2">
                    <input type="number" id="c" placeholder="c" step="any" value="-5">
                </div>
                <div class="matrix-column">
                    <input type="number" id="b" placeholder="b" step="any" value="5">
                    <input type="number" id="d" placeholder="d" step="any" value="2">
                </div>
                <span class="bracket">]</span>
            </div>
        </div>

        <!-- Range Inputs -->
        <div class="range-container">
            <div class="range-row">
                <div class="input-group">
                    <label for="arrow-count">Number of Arrows (per axis):</label>
                    <input type="number" id="arrow-count" value="20">
                </div>
            </div>
        </div>
        
        <div class="button-container">
            <button onclick="drawPhasePortrait()">Generate Phase Portrait</button>
            <button class="clear" onclick="clearUserPoints()">Clear Trajectories</button>
        </div>
        <div class="scale-container">
            <div class="y-scale">
                <span id="y-max-label">10</span>
                <span>5</span>
                <span>0</span>
                <span>-5</span>
                <span id="y-min-label">-10</span>
            </div>
            <div class="canvas-wrapper">
                <div style="position: relative;">
                    <canvas id="canvas" width="600" height="450"></canvas> <!-- Increased dimensions -->
                    <div id="click-instruction" class="click-instruction">Click anywhere to add trajectories</div>
                </div>
                <div class="x-scale">
                    <span id="x-min-label">-10</span>
                    <span>-5</span>
                    <span>0</span>
                    <span>5</span>
                    <span id="x-max-label">10</span>
                </div>
            </div>
        </div>
    </div>

    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script>
        let userPoints = []; // Store user-clicked points

        document.addEventListener('DOMContentLoaded', function() {
            katex.render(
                `\\begin{cases}
                \\dot{x} = ax + by \\\\
                \\dot{y} = cx + dy
                \\end{cases}`,
                document.getElementById('equation-display'),
                { throwOnError: false, displayMode: true }
            );
            drawPhasePortrait();
            
            // Add click listener to canvas
            const canvas = document.getElementById('canvas');
            canvas.addEventListener('click', function(event) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const scale = 30;  // Adjusted for larger canvas
                
                // Convert click coordinates to system coordinates
                const systemX = (x - centerX) / scale;
                const systemY = (centerY - y) / scale;
                
                userPoints.push({x: systemX, y: systemY});
                drawPhasePortrait();
                
                // Fade out the instruction after the first click
                const instruction = document.getElementById('click-instruction');
                instruction.classList.add('fade-out');
            });
        });

        function clearUserPoints() {
            userPoints = []; // Clear stored points
            drawPhasePortrait(); // Redraw without user-generated trajectories
            
            // Make the instruction reappear
            const instruction = document.getElementById('click-instruction');
            instruction.classList.remove('fade-out');
        }

        function drawPhasePortrait() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Get matrix coefficients
            const a = parseFloat(document.getElementById('a').value) || 0;
            const b = parseFloat(document.getElementById('b').value) || 0;
            const c = parseFloat(document.getElementById('c').value) || 0;
            const d = parseFloat(document.getElementById('d').value) || 0;

            // Get arrow count
            const arrowCount = parseFloat(document.getElementById('arrow-count').value) || 20;

            // Fixed range for now since inputs are removed
            const xMin = -10, xMax = 10, yMin = -10, yMax = 10;

            // Update axis labels
            document.getElementById('x-min-label').textContent = xMin;
            document.getElementById('x-max-label').textContent = xMax;
            document.getElementById('y-min-label').textContent = yMin;
            document.getElementById('y-max-label').textContent = yMax;

            // Canvas setup
            const scale = 30;  // Adjusted for larger canvas
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Adjust arrow density to fill the graph
            const xStep = (xMax - xMin) / (arrowCount * 1.5); // Reduced step to increase density
            const yStep = (yMax - yMin) / (arrowCount * 1.5); // Reduced step to increase density

            // Draw vector field (light blue and thinner)
            ctx.strokeStyle = '6CBEC7'; // Light blue color
            ctx.lineWidth = 0.7; // Thinner lines
            for (let x = xMin; x <= xMax; x += xStep) {
                for (let y = yMin; y <= yMax; y += yStep) {
                    const dx = a * x + b * y;
                    const dy = c * x + d * y;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    if (length === 0) continue;

                    // Scale arrow size based on magnitude
                    const arrowScale = Math.min(1, length / 10); // Normalize to a max size
                    const dxNorm = (dx / length) * arrowScale;
                    const dyNorm = (dy / length) * arrowScale;
                    const startX = centerX + x * scale;
                    const startY = centerY - y * scale;
                    drawArrow(ctx, startX, startY, 
                             startX + dxNorm * scale, 
                             startY - dyNorm * scale, arrowScale);
                }
            }

            // Draw predefined trajectories (red)
       /*     ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 2; // Keep original thickness for trajectories
            const predefinedTrajectories = [
                {x: 2, y: 2}, {x: -2, y: 2}, 
                {x: -2, y: -2}, {x: 2, y: -2},
                {x: 3, y: 0}, {x: -3, y: 0}
            ];

            predefinedTrajectories.forEach(point => {
                const path = computeTrajectory(point.x, point.y, a, b, c, d, scale, centerX, centerY);
                drawTrajectory(ctx, path);
            }); */

            // Draw user-added trajectories (green)
            ctx.strokeStyle = '#003161';
            ctx.lineWidth = 2; // Keep original thickness for user trajectories
            userPoints.forEach(point => {
                const path = computeTrajectory(point.x, point.y, a, b, c, d, scale, centerX, centerY);
                drawTrajectory(ctx, path);
            });

            // Draw axes
            ctx.strokeStyle = '#95a5a6';
            ctx.lineWidth = 1.5; // Keep original thickness for axes
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();

            // Label axes
            ctx.fillStyle = '#2c3e50';
            ctx.font = '14px Arial';
            ctx.fillText('x', canvas.width - 10, centerY + 20);
            ctx.fillText('y', centerX + 10, 10);
        }

        function computeTrajectory(x0, y0, a, b, c, d, scale, cx, cy) {
            const dt = 0.0003; // Reduced from 0.0012 for finer step
            const maxSteps = 5000; // Increased to extend trajectory length
            const points = [];
            let x = x0, y = y0;

            // Forward integration
            for (let i = 0; i < maxSteps; i++) {
                points.push({x: cx + x*scale, y: cy - y*scale});
                const dx = a*x + b*y;
                const dy = c*x + d*y;
                x += dx*dt;
                y += dy*dt;
                if (Math.abs(x) > 12 || Math.abs(y) > 9) break; // Adjusted for larger canvas
            }

            // Backward integration
            x = x0, y = y0;
            for (let i = 0; i < maxSteps; i++) {
                const dx = a*x + b*y;
                const dy = c*x + d*y;
                x -= dx*dt;
                y -= dy*dt;
                if (Math.abs(x) > 12 || Math.abs(y) > 9) break; // Adjusted for larger canvas
                points.unshift({x: cx + x*scale, y: cy - y*scale});
            }

            return points;
        }

        function drawTrajectory(ctx, points) {
            ctx.beginPath();
            points.forEach((p, i) => {
                if (i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            });
            ctx.stroke();
        }

        function drawArrow(ctx, fromX, fromY, toX, toY, scale) {
            const angle = Math.atan2(toY - fromY, toX - fromX);
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            
            // Arrowhead (thinner and light blue)
            ctx.lineWidth = 0.7; // Thinner arrowhead
            const arrowSize = 5 * scale; // Scale arrowhead size
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(
                toX - arrowSize * Math.cos(angle - Math.PI/6),
                toY - arrowSize * Math.sin(angle - Math.PI/6)
            );
            ctx.moveTo(toX, toY);
            ctx.lineTo(
                toX - arrowSize * Math.cos(angle + Math.PI/6),
                toY - arrowSize * Math.sin(angle + Math.PI/6)
            );
            ctx.stroke();
        }
    </script>
</body>
</html>
